
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
	<title>Content Management Tool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"
        integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tinymce/tinymce-jquery@2/dist/tinymce-jquery.min.js"></script>
    <script src="https://cdn.tiny.cloud/1/rw00kgcgf2ggfyp0mu3e3upwp7b7f8y6daf38ksflv1g42y3/tinymce/6/tinymce.min.js"
        referrerpolicy="origin"></script>
		<script src="https://cdn.jsdelivr.net/npm/xregexp/xregexp-all.min.js"></script>



    <style>
        * {
            font-family: Calibri;
            font-size: 18px;
        }

        .container {
            text-align: center;
            margin-bottom: 20px;
        }

        button {

            transition-duration: 0.4s;
            font-size: 16px;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 12px;
            border: #90EE90;
            background-color: #32CD32;
            color: black;
            font-weight: bold;
        }

        button:hover {
            background-color: #F0E68C;
            color: black;
        }
        
		button:active {
			box-shadow: 0 5px #666;
			transform: translateY(4px);
		}

        .tools,
        .stats {
            display: none;
            margin-top: 10px;
            padding: 10px;
            text-align: left;
        }

        .tools.show,
        .stats.show {
            display: block;
        }

        .return-to-top-button {
            position: fixed;
            font-size: 18px;
            bottom: 10px;
            left: 10px;
            padding: 5px 10px;
            cursor: pointer;
            background-color: #cae8ca;
            border: 2px solid #4CAF50;
            z-index: 1;
        }

        .container {
            display: flex;
            margin-top: 1%;
        }

        .keywords {
            width: 35%;
            margin-left: 1%;
            border-radius: 11px;
            border: 2px solid #ededed;
            padding: 1%;
        }

        .hemingway-area {
            width: 35%;
            margin-left: 1%;
            border-radius: 11px;
            border: 2px solid #ededed;
            padding: 1%;
            z-index: 999;
        }
		
		.help-area {
            width: 35%;
            margin-left: 1%;
            border-radius: 11px;
            border: 2px solid #ededed;
            padding: 1%;
            z-index: 999;
        }
		
		.keyword-stuffing-area {
            width: 35%;
            margin-left: 1%;
            border-radius: 11px;
            border: 2px solid #ededed;
            padding: 1%;
            z-index: 999;
        }
		
		.list-to-column {
            width: 35%;
            margin-left: 1%;
            border-radius: 11px;
            border: 2px solid #ededed;
            padding: 1%;
            z-index: 999;
        }

        .editor {
            width: 65%;
        }

        .keywords textarea {
            display: none;
            /* Hide the textarea by default */
            width: calc(100% - 20px);
            margin-bottom: 10px;
            resize: vertical;
        }

        .keywords button {
            padding: 8px;
            cursor: pointer;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th,
        td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        .tools-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .stats-container {
            display: flex;
            flex-wrap: wrap;
            /* Allow wrapping to create multiple rows */
            justify-content: space-between;
            /* Distribute items evenly between the two columns */
            gap: 20px;
            /* Add gap between items */
        }

        .stats {
            flex: 0 0 calc(50% - 10px);
            /* Specify initial size for each column with some spacing */
            margin-bottom: 20px;
            /* Add margin to create space between rows */
        }


        .highlighted {
            background-color: #FFA500;
        }
		
        .adverb {
            background: #c4e3f3;
        }

        .qualifier {
            background: #c4e3f3;
        }

        .passive {
            background: #c4ed9d;
        }

        .complex {
            background: #e3b7e8;
        }

        .hardSentence {
            background: #f7ecb5;
        }

        .veryHardSentence {
            background: #e4b9b9;
        }

        .counter {
            position: relative;
            padding: 5% 5%;
            margin: 5% 0 0 5%;
            border-radius: 8px;
        }

        th {
            text-align: center;
        }
		
		#output {
            width: 100%;
            height: 100%;
            overflow: auto;
            margin-top: 10px;
            border: 1px solid #000;
        }
		
		.bolded {
			font-weight: bold;
		}
		
		.density-calculator-container {
    margin-top: 10px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    text-align: left;
}

.density-calculation-row {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.density-calculation-row input {
    margin-right: 10px;
    padding: 5px;
}

.density-calculation-row .remove-field {
    background-color: red;
    color: white;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    border-radius: 5px;
}

.density-calculation-row .remove-field:hover {
    background-color: darkred;
}

info-icon {
    position: absolute;
    top: 10px;  /* Adjust the position as needed */
    right: 10px; /* Adjust the position as needed */
    font-size: 18px;  /* Adjust icon size */
    color: #555; /* Icon color */
    cursor: pointer; /* Cursor changes to pointer on hover */
}

/* Popup styling */
.info-popup {
    display: none; /* Hidden by default */
    position: absolute;
    top: 30px;  /* Adjust the position relative to the icon */
    right: 10px; /* Align with the icon */
    background-color: #f9f9f9;  /* Popup background color */
    border: 1px solid #ccc;  /* Popup border */
    padding: 10px;  /* Space inside the popup */
    border-radius: 4px;  /* Rounded corners */
    width: 250px;  /* Set a fixed width */
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow for popup */
    z-index: 1000;  /* Ensure popup is on top */
}

/* Show popup on hover */
.info-icon:hover + .info-popup {
    display: block;  /* Display the popup */
}

.kw-extraction-area {
    display: none; /* Hidden by default */
    position: relative;
    border: 1px solid #ddd;
    background-color: #f9f9f9;
    padding: 20px;
    margin-top: 10px;
    width: 100%;
}

.result-container {
    display: flex; /* Display children in a row */
    justify-content: space-between; /* Space them out */
    margin-top: 20px;
}

.result-column {
    width: 45%; /* Adjust width as needed */
    border: 1px solid #ccc;
    padding: 10px;
    background-color: #fff;
}

.result-column h3 {
    text-align: center;
    margin-bottom: 10px;
}

.result-column div {
    padding: 5px 0; /* No bullet points, styled as plain text */
    border-bottom: 1px solid #eee; /* Optional: Add separator between items */
}

.meta-tool-area {
    width: 35%;
            margin-left: 1%;
            border-radius: 11px;
            border: 2px solid #ededed;
            padding: 1%;
            z-index: 999;
}

.meta-tool-settings {
    margin-top: 20px;
    padding-top: 10px;
    border-top: 1px solid #ddd;
}

/* Popup message styling */
.popup-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #333;
    color: #fff;
    padding: 15px 30px;
    border-radius: 8px;
    font-size: 16px;
    z-index: 1000; /* Ensure it appears above other content */
    text-align: center;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    opacity: 0; /* Start hidden */
    transition: opacity 0.5s ease; /* Fade transition */
}


    </style>
</head>

<body>
    <div class="tools-container">
        <button class="tools-button" onclick="toggleTools()">Tools</button>
        <button class="stats-button" onclick="toggleStats()">KW Stats</button>
		<button id="copy-content-btn" onclick="copyEditorContent()">Copy Content</button>
        <button  class="help-button" onclick="toggleHelp()">Help</button>
        <div class="tools" id="tools">
            <button class="clean-lists" onclick="cleanBulletPoints()">Fix Formatting</button>
            <button class="capitalize-headings" onclick="capitalizeHeadings()">Capitalize Headings</button>
            <button class="repetition-checker" onclick="findAndHighlightWordRepeats()">Repetition Checker</button>
            <button class="hemingway-tool">Readability Tool</button>
			<button class="keyword-stuffing-btn" onclick="toggleKeywordStuffingChecker()">Word Density Checker</button>
			<button id="toggle-meta-btn" onclick="toggleMetaArea()">Meta T&D</button>
			<button class="density-calculator" id="toggleDensityButton" onclick="toggleDensityCalculator()">Density Calculator</button>
			<button class="list-column-btn" onclick="toggleList">List to Column</button>
			<button id="kw-extraction-btn" onclick="toggleKWExtraction()">KW Extraction</button>

        </div>
		
		<div class="stats" id="stats">
			<div class="stats-container">
				<p>Total number of keywords: <span id="total-keywords">-</span></p>
				<p>Exact Matches: <span id="exact-matches">-</span></p>
				<p>Partial Matches (only): <span id="partial-matches">-</span></p>
				<p>% of Exact Matches: <span id="exact-matches-percentage">-</span></p>
				<p>% of Exact+Partial Matches: <span id="exact-plus-partial-matches-percentage">-</span></p>
			</div>
		</div>

		<div class="container">
		
			<div id="copy-popup" style="display: none;" class="popup-message">Content copied to clipboard!</div>

            <div class="editor">
                <textarea id="tiny" placeholder="Write or Paste your text here"></textarea>
				<button class="return-to-top-button" onclick="returnToTop()">&#x21E7;</button>
            </div>
			
			<!-- Meta Title and Description Tool Area -->
			<div id="right" class="meta-tool-area" style="display: none;">
				<h3>Meta Title</h3>
				<input type="text" id="meta-title" placeholder="Enter Meta Title" oninput="checkMetaTitle()" style="width: 80%; margin-bottom: 5px;">
				<button onclick="copyToClipboard('meta-title')" title="Copy Meta Title">
					<i class="fa fa-copy" style="font-size:14px"></i>
				</button>
				<div id="meta-title-feedback" style="margin-bottom: 15px;"></div>

				<h3>Meta Description</h3>
				<textarea id="meta-description" placeholder="Enter Meta Description" oninput="checkMetaDescription()" style="width: 80%; height: 100px; margin-bottom: 5px;"></textarea>
				<button onclick="copyToClipboard('meta-description')" title="Copy Meta Description">
					<i class="fa fa-copy" style="font-size:14px"></i>
				</button>
				<div id="meta-description-feedback" style="margin-bottom: 15px;"></div>
				
				<button id="add-metas-btn" onclick="addMetasToText()">Add Metas to Text</button>

				<!-- Option to tweak character limits -->
				<div class="meta-tool-settings">
					<h4>Adjust Character Limits</h4>
					<label>Meta Title Min:</label>
					<input type="number" id="title-min" value="50" style="width: 60px;">
					<label>Max:</label>
					<input type="number" id="title-max" value="60" style="width: 60px;"><br><br>

					<label>Meta Description Min:</label>
					<input type="number" id="description-min" value="120" style="width: 60px;">
					<label>Max:</label>
					<input type="number" id="description-max" value="158" style="width: 60px;">
				</div>
			</div>

			
			<div id="right" class="kw-extraction-area" style="display: none; position: relative;">
				<div id="kw-extraction-content">
					
					<i class="fa fa-question-circle info-icon" aria-hidden="true"></i>
					<div class="info-popup">transforms a list of keywords with numbers into two vertical columns separating keywords and number of uses. (Tested on the following formats:<br>"keyword: 51-86"<br>"keyword: 51-86x"<br>"keyword (51-86)"<br>Should work on similar formats but double-check.</div>
                    
					<textarea id="kw-input" placeholder="Enter a list of KWs here, each on a new line..." style="width: 80%; height: 150px; margin-bottom: 10px;"></textarea>
					<button id="transform-btn" onclick="transformKWList()">Transform</button>
					
					
					<div class="result-container">
						<div class="result-column" id="kw-result">
							<h3>Keywords 
								<button onclick="copyListContent('kw-list')" title="Copy Keywords">
									<i class="fa fa-copy" style="font-size:14px"></i>
								</button>
							</h3>
							<div id="kw-list"></div>
						</div>

						<div class="result-column" id="uses-result">
							<h3>Required Amount 
								<button onclick="copyListContent('uses-list')" title="Copy Required Amount">
									<i class="fa fa-copy" style="font-size:14px"></i>
								</button>
							</h3>
							<div id="uses-list"></div>
						</div>
					</div>

				</div>
			</div>

            <div class="hemingway-area" style="display: none;">
			
                <div id="right">
                    <button class="HemBtn" onclick="HemingwayCalculator()">Test Me</button>
					<i class="fa fa-question-circle info-icon" aria-hidden="true"></i>
					<div class="info-popup">This tool analyzes the readability of your text based on the Hemingway scale. Aim for 9 or lower. 10 is fine, 11+ too hard to read.</div>
                    <p>Readability Grade: <span id="hemingway-grade">-</span></p>
                    <div id="adverb" class="adverb counter"></div>
                    <div id="passive" class="passive counter"></div>
                    <div id="complex" class="complex counter"></div>
                    <div id="hardSentence" class="hardSentence counter"></div>
                    <div id="veryHardSentence" class="veryHardSentence counter"></div>
                </div>
            </div>
			
<div class="list-to-column" style="display: none;">
    <div id="right">
        <textarea id="input" placeholder="Enter words separated by commas"></textarea><br>
        <button onclick="transform()">Transform</button>
        <button onclick="copyListContent('output')" title="Copy Transformed List">
            <i class="fa fa-copy" style="font-size:14px"></i>
        </button>
        <i class="fa fa-question-circle info-icon" aria-hidden="true"></i>
        <div class="info-popup">This tool transforms a comma-separated list of words into a vertical column format, ready to be copy/pasted into the KW checker.</div>
        <div id="output"></div>
    </div>
</div>

			
			<div class="density-calculator-container" style="display: none;">
				<h3>Density Calculator <i class="fa fa-question-circle info-icon" aria-hidden="true"></i>
    <div class="info-popup" style="font-weight: normal;">Calculate the exact number or range of KW uses based on word count and density requirements. Insert the word count as a number or range (eg, 1300 or 1300-1500). Then, insert the density percentage (eg, 2%). Hit "Calculate" to get the result.</div></h3> 
				<div id="densityCalculatorFields">
					<div class="density-calculation-row">
						<input type="text" class="word-count" placeholder="Enter word count (e.g., 1300 or 1300-1500)">
						<input type="text" class="kw-density" placeholder="Enter desired KW density (e.g., 3%)">
						<input type="text" class="density-result" readonly placeholder="Result">
						<button class="remove-field" onclick="removeField(this)">Remove</button>
					</div>
				</div>
				<button onclick="addDensityField()">Add Another Density</button>
				<button onclick="calculateDensity()">Calculate</button>
			</div>
						
			<div class="help-area" style="display: none;">
				<div id="right">
					<h2 style="text-align: center; font-size: 22px;">Tools</h1>
					<div style="text-align: left;">
					<p><strong>Fix Formatting</strong>: removes empty paragraphs, leading and trailing spaces and 2+ whitespace.</p>
					<p><strong>Capitalize Headings:</strong> follows APA Style. It's primarily for English but should work also in German, Spanish, French and Italian (still better to double-check to avoid mistakes).</p>
					<p><strong>Repetition Checker:</strong> highlights in orange words repeated within 130 characters and in light blue those repeated between 131 and 300 characters.</p>
					<p><strong>Readability Tool:</strong> loosely based on Hemingway App (shares the same grades but other stats are slightly different). Everything equal or lower than 9 is considered "Easy to read". 10 is ok. From 11 up, it's too hard. For more info: <a href="https://readable.com/wp-content/uploads/2019/01/ARITABLE.png" target="_blank">HERE</a> and <a href="https://en.wikipedia.org/wiki/Automated_readability_index" target="_blank">HERE</a></p>
					<p><strong>Word Density Checker:</strong> calculates the top 20 words by density in your text, excluding common words and words shorter than 4 characters.</p>
					<p><strong>Density Calculator:</strong> calculates the exact number or range of KW uses based on word count and density requirements. Insert the word count as a number or range (eg, 1300 or 1300-1500). Then, insert the density percentage (eg, 2%). Hit "Calculate" to get the result.</p>
					<p><strong>List to Column:</strong> transforms a list of words separated by commas into a vertical column list.</p>
					<p><strong>KW Extraction:</strong> transforms a list of keywords with numbers into two vertical columns separating keywords and number of uses. (Tested on the following formats: "keyword: 51-86", "keyword: 51-86x", "keyword (51-86)". Should work on similar formats but better to double-check.)</p>
					<h2 style="text-align: center; font-size: 22px;">Keyword Checker</h2>
					<p><strong>Add Keywords:</strong> accepts one keyword per line.</p>
					<p><strong>Add Required Amount:</strong> accepts numbers (10), ranges (1-20 or 1 - 20), and percentages (5%). One per line, they correspond to the line of the "Add Keywords" section. If no data, default range is 1-100.</p>
					<p><strong>Analyze Keywords:</strong> activates the keyword analysis. Results in the table update only when this button is clicked. Clicking also calculates Stats shown in the relevant tab.</p>
					<p><strong>Exact Matches:</strong> returns the number of occurrences and density percentage of words exactly as inserted in the keyword area.</p>
					<p><strong>Partial Matches:</strong> returns the number of occurrences of words that have slight differences with the provided keyword, such as prefixes, suffixes and diacritics. (keyword = cafè; partial matches are "cafe", "cafès", "ecafè"). The density percentage shown includes the density of "Exact Matches".</p>
					</div>
				</div>
			</div>
			
			<div class="keyword-stuffing-area" style="display: none;">
				<div id="right">
					
					<button class="calculate-density-btn" onclick="analyzeText()">Calculate</button>
					<i class="fa fa-question-circle info-icon" aria-hidden="true"></i>
					<div class="info-popup">This tool calculates the top 20 words by density in your text, excluding common words and words shorter than 4 characters.</div>

					<!-- Results Display Area -->
					<div id="wordAnalysisResult"></div>
				</div>
			</div>

            <div class="keywords">
                <textarea id="keywordInput" placeholder="Paste your keywords here"></textarea>
                <textarea id="requiredAmountInput" placeholder="Insert required amounts (one per line)"
                    style="display: none;"></textarea>
                <button id="addKeywordsBtn">Add Keywords</button>
                <button id="addRequiredAmountBtn">Add Required Amount</button></br></br>
                <button id="analyzeKeywordsBtn" onclick="analyzeKeywords()">Analyze Keywords</button>
				<button class="highlight-keywords-button" onclick="toggleKeywordHighlighting()">Highlight All</button>
				<button class="bold-keywords-button" onclick="toggleKeywordBolding()">Bold All</button>
                <h3>Keyword Results</h3>
                <table id="keywordResults">
                    <thead>
                        <tr>
                            <th>Keyword</th>
                            <th>Exact Matches</th>
                            <th>Partial Matches</th>
                            <th>Required</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
		$('textarea#tiny').tinymce({
			height: 500,
			menubar: false,
			browser_spellcheck: true,
			entity_encoding: 'raw',
			selector: 'textarea#tiny',
			contextmenu: false,
			plugins: [
				'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
				'anchor', 'searchreplace', 'visualblocks', 'fullscreen',
				'insertdatetime', 'media', 'table', 'code', 'help', 'wordcount', 'paste'
			],
			toolbar: ' blocks | bold italic backcolor | ' +
				'alignleft aligncenter alignright alignjustify | ' +
				'bullist numlist outdent indent | table | ' +
				'link | image | media | ' +
				'removeformat | undo redo | wordcount | searchreplace | help',
			menu: {
				file: { title: 'File', items: 'newdocument restoredraft | preview | export | print | deleteallconversations' },
				edit: { title: 'Edit', items: 'undo redo | cut copy paste pastetext | selectall | searchreplace' },
				view: { title: 'View', items: 'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments' },
				insert: { title: 'Insert', items: 'image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents | insertdatetime' },
				format: { title: 'Format', items: 'bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat' },
				tools: { title: 'Tools', items: 'spellchecker spellcheckerlanguage | a11ycheck code wordcount' },
				table: { title: 'Table', items: 'inserttable | cell row column | advtablesort | tableprops deletetable' },
				help: { title: 'Help', items: 'help' }
			},
			menubar: 'favs file edit view insert format tools table help',
			content_css: 'css/content.css',
			paste_retain_style_properties: 'all',
			paste_webkit_styles: 'all',
			paste_word_valid_elements: "b,strong,i,em,li,ol,ul",

			// Automatically fix formatting when text is pasted
			setup: function (editor) {
				editor.on('Paste', function () {
            // Use a timeout to ensure the paste is complete before fixing formatting
            setTimeout(function () {
                fixFormatting();
            }, 100); // 100ms delay to ensure paste completion
				});
			}
		});

		
//Keyword Checker
function analyzeKeywords() {
    console.log("Analyzing keywords...");
    try {
        var editor = tinymce.get('tiny');
        if (!editor) {
            console.error("TinyMCE editor not found.");
            return;
        }
        
        var totalWordCount = editor.plugins.wordcount.getCount();
        var keywordInput = document.getElementById('keywordInput');
        if (!keywordInput) {
            console.error("Keyword input element not found.");
            return;
        }
        
        var keywords = keywordInput.value.split('\n').map(keyword => keyword.trim()).filter(Boolean);
        var requiredAmountInput = document.getElementById('requiredAmountInput');
        if (!requiredAmountInput) {
            console.error("Required amount input element not found.");
            return;
        }
        
        var requiredAmounts = requiredAmountInput.value.split('\n').map(entry => entry.trim()).filter(Boolean);
        var content = editor.getContent({ format: 'text' });

        var keywordResultsTable = document.getElementById('keywordResults').getElementsByTagName('tbody')[0];
        if (!keywordResultsTable) {
            console.error("Keyword results table not found.");
            return;
        }
        
        keywordResultsTable.innerHTML = '';

        var totalKeywords = keywords.length; // Calculate total number of keywords
        var exactMatchesCount = 0; // Initialize exact matches count
        var partialMatchesOnlyCount = 0; // Initialize partial matches only count

        keywords.forEach(function (keyword, index) {
            // Create a case-insensitive regular expression to match the keyword as a whole word
            var pattern = new RegExp('(?<=^|\\s|[\'"“”\\(\\)])' + escapeRegExp(keyword) + '(?=[\\s.,;:!?\'"“”\\(\\)]|$)', 'gi');

            // Find exact matches and partial matches
            var matches = content.match(pattern) || [];
            var exactMatches = countExactMatches(matches, keyword);
            var partialMatches = countPartialMatches(content, keyword);

            // Count exact matches and partial matches
            if (exactMatches > 0) {
                exactMatchesCount++;
            } else if (partialMatches > 0) {
                partialMatchesOnlyCount++;
            }

            var row = keywordResultsTable.insertRow();
            var cell1 = row.insertCell(0);
            var cell2 = row.insertCell(1);
            var cell3 = row.insertCell(2);
            var cell4 = row.insertCell(3);

            cell1.innerHTML = keyword;
            cell2.innerHTML = exactMatches + "<br>" + " (" + ((exactMatches / totalWordCount) * 100).toFixed(2) + '%' + ")";
            cell3.innerHTML = partialMatches - exactMatches + "<br>" + " (" + (partialMatches / totalWordCount * 100).toFixed(2) + '%)';
            cell4.innerHTML = formatRequiredAmount(parseRequiredAmount(requiredAmounts[index]));

            // Check if the actual count is within the specified range
            var countInRange = isCountInRange(exactMatches, parseRequiredAmount(requiredAmounts[index]));
            cell4.className = countInRange ? 'count-in-range' : 'count-out-of-range';

            // Add visual hints based on comparison
            addVisualHints(cell4, exactMatches, parseRequiredAmount(requiredAmounts[index]), totalWordCount);
        });

        // Update the display of total number of keywords in Stats
        var totalKeywordsElement = document.getElementById('total-keywords');
        if (totalKeywordsElement) {
            totalKeywordsElement.textContent = totalKeywords;
        } else {
            console.error("Total keywords element not found.");
        }

        // Update the display of number of exact matches
        var exactMatchesElement = document.getElementById('exact-matches');
        if (exactMatchesElement) {
            exactMatchesElement.textContent = exactMatchesCount;
        } else {
            console.error("Exact matches element not found.");
        }

        // Update the display of partial matches only
        var partialMatchesElement = document.getElementById('partial-matches');
        if (partialMatchesElement) {
            partialMatchesElement.textContent = partialMatchesOnlyCount;
        } else {
            console.error("Partial matches element not found.");
        }

        // Calculate and update the percentage of exact matches and exact+partial matches
        calculateKeywordsPercentages(totalKeywords, exactMatchesCount, partialMatchesOnlyCount);
    } catch (error) {
        console.error("An error occurred during keyword analysis:", error);
    }
}

// Function to count exact matches of a keyword in the content
function countExactMatches(matches, keyword) {
    var count = 0;
    matches.forEach(function (match) {
        if (match === keyword || containsEquivalentDiacritics(match, keyword), 'gi') {
            count++;
        }
    });
    return count;
}

// Function to count partial matches considering diacritics and different character sets
function countPartialMatches(content, keyword) {
    var normalizedContent = normalizeDiacritics(content);
    var partialPattern = new RegExp(normalizeDiacritics(keyword), 'gi');
    var matches = normalizedContent.match(partialPattern) || [];
    return matches.length;
}

// Function to check if a string contains equivalent diacritics of a keyword
function containsEquivalentDiacritics(str, keyword) {
    var normalizedStr = normalizeDiacritics(str);
    var normalizedKeyword = normalizeDiacritics(keyword);
    return normalizedStr !== normalizedKeyword && normalizedStr.includes(normalizedKeyword);
}

// Function to normalize diacritics in a string
function normalizeDiacritics(str) {
    return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
}

// Function to escape special characters in a string for use in regular expressions
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Function to calculate the percentage of exact matches and exact+partial matches
function calculateKeywordsPercentages(totalKeywords, exactMatchesCount, partialMatchesOnlyCount) {
    var exactMatchesPercentage = (exactMatchesCount / totalKeywords) * 100;
    var exactPlusPartialMatchesPercentage = ((exactMatchesCount + partialMatchesOnlyCount) / totalKeywords) * 100;

    var exactMatchesPercentageElement = document.getElementById('exact-matches-percentage');
    exactMatchesPercentageElement.textContent = exactMatchesPercentage.toFixed(2) + '%';

    var exactPlusPartialMatchesPercentageElement = document.getElementById('exact-plus-partial-matches-percentage');
    exactPlusPartialMatchesPercentageElement.textContent = exactPlusPartialMatchesPercentage.toFixed(2) + '%';
}

// Function to add visual hints to the required amount column based on matches
function addVisualHints(cell, exactMatches, requiredAmount, totalWordCount) {
    if (typeof requiredAmount === 'number') {
        // Case 1: Required is an integer
        addVisualHintForInteger(cell, exactMatches, requiredAmount);
    } else if (typeof requiredAmount === 'object' && requiredAmount.min !== undefined && requiredAmount.max !== undefined) {
        // Case 2: Required is a Range
        addVisualHintForRange(cell, exactMatches, requiredAmount);
    } else if (typeof requiredAmount === 'object' && requiredAmount.percentage !== undefined) {
        // Case 3: Required is a Percentage
        addVisualHintForPercentage(cell, exactMatches, requiredAmount, totalWordCount);
    } else if (typeof requiredAmount === 'object' && ('percentage' in requiredAmount)) {
        // Case 4: Required is a Percentage Range
        addVisualHintForPercentageRange(cell, exactMatches, { percentage: requiredAmount }, totalWordCount);
    }
}

function addVisualHintForInteger(cell, exactMatches, requiredAmount) {
    var difference = Math.abs(exactMatches - requiredAmount);

    if (difference === 0) {
        cell.style.backgroundColor = 'green'; // Numbers are the same
    } else if (difference === 1) {
        cell.style.backgroundColor = 'orange'; // Difference is +/- 1
    } else {
        cell.style.backgroundColor = 'red'; // Difference is higher than +/- 1
    }
}

function addVisualHintForRange(cell, exactMatches, requiredAmount) {
    if (exactMatches >= requiredAmount.min && exactMatches <= requiredAmount.max) {
        cell.style.backgroundColor = 'green'; // Exact match is within the range
    } else if (Math.abs(exactMatches - requiredAmount.min) === 1 || Math.abs(exactMatches - requiredAmount.max) === 1) {
        cell.style.backgroundColor = 'orange'; // Difference is +/- 1 from the range
    } else {
        cell.style.backgroundColor = 'red'; // Difference is higher than +/- 1 from the range
    }
}

function addVisualHintForPercentage(cell, exactMatches, requiredAmount, totalWordCount) {
    var requiredPercentage = (exactMatches / totalWordCount) * 100;

    // Calculate the absolute difference
    var difference = Math.abs(requiredPercentage - requiredAmount.percentage);

    if (difference <= 0.5) {
        cell.style.backgroundColor = 'orange'; // Difference is within +/- 0.5%
    } else if (requiredPercentage.toFixed(2) === requiredAmount.percentage.toFixed(2)) {
        cell.style.backgroundColor = 'green'; // Percentages are the same
    } else {
        cell.style.backgroundColor = 'red'; // Percentages are different and outside tolerance
    }
}

function addVisualHintForPercentageRange(cell, exactMatches, requiredAmount, totalWordCount) {
    // Check if requiredAmount contains a range (e.g., "1%-2%" or "1% - 2%")
    if ('percentageMin' in requiredAmount && 'percentageMax' in requiredAmount) {
        // Extract min and max values from the range
        var requiredPercentageMin = requiredAmount.percentageMin;
        var requiredPercentageMax = requiredAmount.percentageMax;

        // Calculate the percentage based on exactMatches and totalWordCount
        var calculatedPercentage = (exactMatches / totalWordCount) * 100;

        if (!isNaN(requiredPercentageMin) && !isNaN(requiredPercentageMax)) {
            // Percentage is within the range
            if (calculatedPercentage >= requiredPercentageMin && calculatedPercentage <= requiredPercentageMax) {
                cell.style.backgroundColor = 'green';
            }
            // Difference is within +/- 0.5% from the range
            else if (Math.abs(calculatedPercentage - requiredPercentageMin) <= 0.5 || Math.abs(calculatedPercentage - requiredPercentageMax) <= 0.5) {
                cell.style.backgroundColor = 'orange';
            }
            // Difference is higher than +/- 0.5% from the range
            else {
                cell.style.backgroundColor = 'red';
            }
        }
    } else {
        // Handle single percentage case
        addVisualHintForPercentage(cell, exactMatches, requiredAmount, totalWordCount);
    }
}

function parseRequiredAmount(entry) {
    // Check if the entry is empty
    if (!entry) {
        return { min: 1, max: 100 }; // Return range between 1 and 100 if empty
    }

    // Check if the entry is a percentage range
    if (entry.includes('%')) {
        var rangeValues = entry.split('-').map(val => val.trim());
        if (rangeValues.length === 2 && !isNaN(parseFloat(rangeValues[0])) && !isNaN(parseFloat(rangeValues[1]))) {
            return { percentageMin: parseFloat(rangeValues[0]), percentageMax: parseFloat(rangeValues[1]) };
        }
    }

    // Check if the entry is a percentage
    if (entry.endsWith('%')) {
        var percentage = parseFloat(entry.slice(0, -1));
        return { percentage: percentage };
    }

    // Check if the entry is an integer range
    if (entry.includes('-')) {
        var rangeValues = entry.split('-').map(val => parseInt(val.trim()));
        if (rangeValues.length === 2 && !isNaN(rangeValues[0]) && !isNaN(rangeValues[1])) {
            return { min: rangeValues[0], max: rangeValues[1] };
        }
    }

    // Treat as a single integer
    var intValue = parseInt(entry);
    return isNaN(intValue) ? 0 : intValue;
}

function formatRequiredAmount(requiredAmount) {
    if (typeof requiredAmount === 'number') {
        return requiredAmount.toString();
    } else if (typeof requiredAmount === 'object' && requiredAmount.percentage !== undefined) {
        return requiredAmount.percentage + '%';
    } else if (typeof requiredAmount === 'object' && requiredAmount.min !== undefined && requiredAmount.max !== undefined) {
        return requiredAmount.min + ' - ' + requiredAmount.max;
    }
    return '';
}

function isCountInRange(count, requiredAmount) {
    if (typeof requiredAmount === 'number') {
        return count >= requiredAmount;
    } else if (typeof requiredAmount === 'object' && requiredAmount.min !== undefined && requiredAmount.max !== undefined) {
        return count >= requiredAmount.min && count <= requiredAmount.max;
    }
    return false;
}

function calculateKeywordsPercentage() {
    var editor = tinymce.get('tiny');
    var totalWordCount = editor.plugins.wordcount.getCount();
    var keywordInput = document.getElementById('keywordInput');
    var keywords = keywordInput.value.split('\n').map(keyword => keyword.trim()).filter(Boolean);
    var requiredAmountInput = document.getElementById('requiredAmountInput');
    var requiredAmounts = requiredAmountInput.value.split('\n').map(entry => entry.trim()).filter(Boolean);
    var usedKeywordsCount = 0;

    keywords.forEach(function (keyword, index) {
        var escapedKeyword = escapeRegExp(keyword);
        var requiredAmount = parseRequiredAmount(requiredAmounts[index]);
        var pattern = new RegExp('(?:\\p{L}|\\W)' + escapedKeyword + '(?:\\p{L}|\\W)', 'giu');
        var content = editor.getContent({ format: 'text' });
        var matches = content.match(pattern) || [];
        var exactMatches = matches.length;

        if (isCountInRange(exactMatches, requiredAmount)) {
            usedKeywordsCount++;
        }
    });

    var keywordsPercentage = (usedKeywordsCount / keywords.length) * 100;
    var keywordsPercentageElement = document.getElementById('keywords-percentage');
    keywordsPercentageElement.textContent = keywordsPercentage.toFixed(2) + '%';
}

// Bind the function to the "Calculate" button click event
var analyzeKeywordsBtn = document.getElementById('analyzeKeywordsBtn');
analyzeKeywordsBtn.addEventListener('click', function () {
    calculateKeywordsPercentage();
});

//End of Keyword Checker


		


// Variable to track whether keyword highlighting is on or off
var isHighlightingOn = false;

// Helper function to escape special characters in a string for use in regular expressions
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Function to highlight keywords
function highlightKeywordOccurrences(node, keywords) {
    var text = node.nodeValue;
    keywords.forEach(function (keyword) {
        var pattern = new RegExp('\\b' + escapeRegExp(keyword) + '\\b', 'gi');
        text = text.replace(pattern, function(match) {
            return '<span class="highlighted" style="background-color: yellow;">' + match + '</span>';
        });
    });

    var wrapper = document.createElement('span');
    wrapper.innerHTML = text;
    node.parentNode.replaceChild(wrapper, node);
}

function traverseAndHighlight(node, keywords) {
    if (node.nodeType === Node.TEXT_NODE) {
        highlightKeywordOccurrences(node, keywords);
    } else if (node.nodeType === Node.ELEMENT_NODE && node.childNodes) {
        for (var i = 0; i < node.childNodes.length; i++) {
            traverseAndHighlight(node.childNodes[i], keywords);
        }
    }
}

// Function to remove keyword highlighting
function removeKeywordHighlighting() {
    var editor = tinymce.get('tiny');
    var rootNode = editor.getBody();
    var highlightedSpans = rootNode.querySelectorAll('.highlighted');

    highlightedSpans.forEach(function (span) {
        var parent = span.parentNode;
        while (span.firstChild) {
            parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
    });

    isHighlightingOn = false;
}

// Function to highlight keywords
function highlightKeywords() {
    var editor = tinymce.get('tiny');
    var rootNode = editor.getBody();
    var keywordInput = document.getElementById('keywordInput');
    var keywords = keywordInput.value.split('\n').map(keyword => keyword.trim()).filter(Boolean);

    console.log('Keywords:', keywords); // Log the keywords

    traverseAndHighlight(rootNode, keywords);
    isHighlightingOn = true;
}

// Function to toggle keyword highlighting
function toggleKeywordHighlighting() {
	var toggleButton = $('.highlight-keywords-button');
	
    if (isHighlightingOn) {
        removeKeywordHighlighting();
		toggleButton.text('Highligh All');
		
    } else {
        highlightKeywords();
		toggleButton.text('Remove Highlighs');
    }
}

// Variable to track whether keyword bolding is on or off
var isBoldingOn = false;

function traverseAndBold(node, keywords) {
    if (node.nodeType === Node.TEXT_NODE) {
        boldKeywordOccurrences(node, keywords);
    } else if (node.nodeType === Node.ELEMENT_NODE && node.childNodes) {
        for (var i = 0; i < node.childNodes.length; i++) {
            traverseAndBold(node.childNodes[i], keywords);
        }
    }
}


// Function to bold keywords
function boldKeywords() {
    var editor = tinymce.get('tiny');
    var rootNode = editor.getBody();
    var keywordInput = document.getElementById('keywordInput');
    var keywords = keywordInput.value.split('\n').map(keyword => keyword.trim()).filter(Boolean);

    console.log('Keywords:', keywords); // Log the keywords

    traverseAndBold(rootNode, keywords);
    isBoldingOn = true;
}

// Function to bold keywords
function boldKeywordOccurrences(node, keywords) {
    var text = node.nodeValue;
    keywords.forEach(function (keyword) {
        var pattern = new RegExp('\\b' + escapeRegExp(keyword) + '\\b', 'gi');
        text = text.replace(pattern, function(match) {
            return '<span class="bolded"><strong>' + match + '</strong></span>';
        });
    });

    var wrapper = document.createElement('span');
    wrapper.innerHTML = text;
    node.parentNode.replaceChild(wrapper, node);
}

// Function to remove keyword bolding
function removeBolding() {
    var editor = tinymce.get('tiny');
    var rootNode = editor.getBody();
    var boldedSpans = rootNode.querySelectorAll('.bolded');

    boldedSpans.forEach(function (span) {
        var parent = span.parentNode;
        var strongElements = span.querySelectorAll('strong');
        strongElements.forEach(function (strong) {
            var textNode = document.createTextNode(strong.textContent);
            strong.parentNode.replaceChild(textNode, strong);
        });
        parent.insertBefore(span.firstChild, span);
        parent.removeChild(span);
    });

    isBoldingOn = false;
}


// Function to toggle keyword bolding
function toggleKeywordBolding() {
	var toggleButton = $('.bold-keywords-button');
	
    if (isBoldingOn) {
        removeBolding();
		toggleButton.text('Bold All');
    } else {
        boldKeywords();
		toggleButton.text('Remove Bolding');
    }
}





// list to column		
function toggleList() {
    var listArea = document.querySelector('.list-to-column');
    var listButton = document.querySelector('.list-column-btn');

    if (listArea.style.display === 'none' || listArea.style.display === '') {
        listArea.style.display = 'block';
        listButton.textContent = 'Hide List to Column';
    } else {
        listArea.style.display = 'none';
        listButton.textContent = 'List to Column';
    }

    // Toggle the visibility of the Keyword area as well
    var keywordArea = document.querySelector('.keywords');
    keywordArea.style.display = listArea.style.display === 'block' ? 'none' : 'block';
}

// Bind the function to the button click event
var listButton = document.querySelector('.list-column-btn');
listButton.addEventListener('click', toggleList);
		
		function transform() {
            var input = document.getElementById('input').value;
            var words = input.split(',');
            var output = document.getElementById('output');
            output.innerHTML = '';
            for (var i = 0; i < words.length; i++) {
                output.innerHTML += words[i].trim() + '<br>';
            }
        }
		
		function toggleHelp() {
			var helpArea = document.querySelector('.help-area');
			var helpButton = document.querySelector('.help-button');
			
			if (helpArea.style.display === 'none') {
                helpArea.style.display = 'block';
                helpButton.textContent = 'Hide Help';
            } else {
                helpArea.style.display = 'none';
                helpButton.textContent = 'Help';
            }

            // Toggle the visibility of the Keyword area as well
            var keywordArea = document.querySelector('.keywords');
            keywordArea.style.display = helpArea.style.display === 'block' ? 'none' : 'block';
        }

        // Bind the function to the button click event
        var helpButton = document.querySelector('.hemingway-tool');
        helpButton.addEventListener('click', toggleHemingwayTool);
		
		function toggleTools() {
            var instructions = document.getElementById('tools');
            instructions.classList.toggle('show');

            var toolsButton = document.querySelector('.tools-button');
            toolsButton.textContent = instructions.classList.contains('show') ? 'Hide Tools' : 'Tools';
        }

        function toggleStats() {
            var statsArea = document.getElementById('stats');
            statsArea.classList.toggle('show');

            var statsButton = document.querySelector('.stats-button');
            statsButton.textContent = statsArea.classList.contains('show') ? 'Hide KW Stats' : 'KW Stats';
        }

        var addKeywordsBtn = document.getElementById('addKeywordsBtn');
        var keywordInput = document.getElementById('keywordInput');

        keywordInput.style.display = 'none';

        addKeywordsBtn.addEventListener('click', function () {
            if (keywordInput.style.display === 'none') {
                keywordInput.style.display = 'block';
                addKeywordsBtn.textContent = 'Hide Keywords';
            } else {
                keywordInput.style.display = 'none';
                addKeywordsBtn.textContent = 'Add Keywords';
            }
        });

        var addRequiredAmountBtn = document.getElementById('addRequiredAmountBtn');
        var requiredAmountInput = document.getElementById('requiredAmountInput');

        addRequiredAmountBtn.addEventListener('click', function () {
            if (requiredAmountInput.style.display === 'none') {
                requiredAmountInput.style.display = 'block';
                addRequiredAmountBtn.textContent = 'Hide Required Amount';
            } else {
                requiredAmountInput.style.display = 'none';
                addRequiredAmountBtn.textContent = 'Add Required Amount';
            }
        });

function fixSpaces() {
    var editor = tinymce.get('tiny');
    var content = editor.getContent({ format: 'html' });

    // Use a DOMParser to parse the string into a document object
    var parser = new DOMParser();
    var doc = parser.parseFromString(content, 'text/html');

    // Helper function to trim leading spaces of the first text node and trailing spaces of the last text node
    function trimElementBoundarySpaces(element) {
        var firstTextNode = null;
        var lastTextNode = null;

        // Traverse to find the first text node
        function findFirstTextNode(node) {
            if (node.nodeType === 3 && node.nodeValue.trim().length > 0) {
                return node;
            }
            for (var i = 0; i < node.childNodes.length; i++) {
                var foundNode = findFirstTextNode(node.childNodes[i]);
                if (foundNode) {
                    return foundNode;
                }
            }
            return null;
        }

        // Traverse to find the last text node
        function findLastTextNode(node) {
            if (node.nodeType === 3 && node.nodeValue.trim().length > 0) {
                return node;
            }
            for (var i = node.childNodes.length - 1; i >= 0; i--) {
                var foundNode = findLastTextNode(node.childNodes[i]);
                if (foundNode) {
                    return foundNode;
                }
            }
            return null;
        }

        firstTextNode = findFirstTextNode(element);
        lastTextNode = findLastTextNode(element);

        if (firstTextNode) {
            firstTextNode.nodeValue = firstTextNode.nodeValue.replace(/^\s+/, '');
        }
        if (lastTextNode) {
            lastTextNode.nodeValue = lastTextNode.nodeValue.replace(/\s+$/, '');
        }
    }

    // Process all paragraphs and headings
    var tagsToProcess = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
    tagsToProcess.forEach(function(tag) {
        doc.querySelectorAll(tag).forEach(function(element) {
            trimElementBoundarySpaces(element);
        });
    });

    // Set the modified content back to the editor
    editor.setContent(doc.body.innerHTML);
}

function removeEmptyParagraphs() {
    var editor = tinymce.get('tiny');
    var content = editor.getContent();

    var tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Select all paragraphs and headings in the content
    var elements = tempDiv.querySelectorAll('p, h1, h2, h3, h4, h5, h6');

    // Remove empty elements that do not contain images, tables, or text
    for (var i = elements.length - 1; i >= 0; i--) {
        var elementContent = elements[i].textContent.trim();
        var hasNonTextContent = elements[i].querySelector('img, table') !== null;

        if (elementContent === '' && !hasNonTextContent) {
            elements[i].remove();
        }
    }

    editor.setContent(tempDiv.innerHTML);
}

function cleanBulletPoints() {
    var listItems = tinymce.activeEditor.dom.select('ul li, ol li');
    listItems.forEach(function (listItem) {
        var paragraphs = listItem.querySelectorAll('p');
        paragraphs.forEach(function (paragraph) {
            if (paragraph.parentNode === listItem) {
                // Move content outside of <p> elements while preserving images
                while (paragraph.firstChild) {
                    listItem.insertBefore(paragraph.firstChild, paragraph);
                }
                tinymce.activeEditor.dom.remove(paragraph);
            }
        });
    });
}

function fixFormatting() {
    fixSpaces();
    removeEmptyParagraphs();
    cleanBulletPoints();
}

// Add event listener to the button
var fixSpacesButton = document.querySelector('.clean-lists');
fixSpacesButton.addEventListener('click', fixFormatting);


// Capitalize Headings
function capitalizeHeadings() {
    var editor = tinymce.get('tiny');
    var content = editor.getContent();

    var tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Select all headings in the content
    var headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6');

    // List of words to exclude from capitalization (APA style)
    var excludedWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet', 'ad', 'al', 'allo', 'ai', 'il', 'agli', 'all', 'alla', 'alle', 'con', 'col', 'coi', 'da', 'dal', 'dallo', 'dai', 'dagli', 'dall', 'dalla', 'dalle', 'di', 'del', 'dello', 'dei', 'degli', 'dell', 'della', 'delle', 'in', 'un', 'una', 'la', 'lo', 'gli', 'nel', 'nello', 'nei', 'negli', 'nell', 'nella', 'nelle', 'su', 'sul', 'sullo', 'sui', 'sugli', 'sull', 'sulla', 'sulle', 'y', 'e', 'o', 'u', 'con', 'de', 'desde', 'en', 'entre', 'hacia', 'hasta', 'para', 'por', 'según', 'sin', 'sobre', 'tras', 'ante', 'bajo', 'cabe', 'contra', 'durante', 'mediante', 'excepto', 'salvo', 'toda', 'todas', 'todo', 'todos', 'und', 'oder', 'aber', 'denn', 'doch', 'also', 'nur', 'jedoch', 'weder', 'sowie', 'sodass', 'weil', 'dass', 'obwohl', 'trotzdem', 'falls', 'weiter', 'zwar', 'nämlich', 'ja', 'nein', 'doch', 'denn', 'auch', 'nicht', 'sehr', 'mehr', 'wenig', 'viel', 'a', 'o', 'as', 'os', 'à', 'ao', 'às', 'aos', 'de', 'do', 'da', 'dos', 'das', 'em', 'no', 'na', 'nos', 'nas', 'por', 'pelo', 'pela', 'pelos', 'pelas', 'com', 'sem', 'sob', 'sobre', 'ante', 'após', 'até', 'contra', 'entre'];

    // List of words to be preserved in their original format
    var preservedWords = ['FAQ', 'FAQs', 'USA', 'UK', 'UN', 'EU', 'FS', 'CA', 'SA', 'ZAR', 'CA$', 'US$', 'AU', 'AU$', 'NZ', 'NZ$']; // Add more words as needed

    // Function to capitalize according to APA style
    function capitalizeAPA(text) {
        return text.toLowerCase().replace(/(?:^|\s)\S/g, function (a) {
            return a.toUpperCase();
        }).replace(new RegExp('\\b(?:' + excludedWords.join('|') + ')\\b', 'giu'), function (word) {
            return word.toLowerCase();
        });
    }

    // Function to remove punctuation for comparison
    function stripPunctuation(word) {
        return word.replace(/[.,!?;:()"]/g, '');
    }

    // Loop through headings and apply APA capitalization
    headings.forEach(function (heading) {
        var headingText = heading.textContent.trim();
        var words = headingText.split(' ');

        for (var i = 0; i < words.length; i++) {
            var wordWithoutPunctuation = stripPunctuation(words[i]);

            if (preservedWords.includes(wordWithoutPunctuation)) {
                continue; // Preserve the word in its original form
            }
            if (i === 0 && excludedWords.includes(wordWithoutPunctuation.toLowerCase())) {
                words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1).toLowerCase();
            } else {
                words[i] = capitalizeAPA(words[i]);
            }
        }

        heading.textContent = words.join(' ');
    });

    editor.setContent(tempDiv.innerHTML);
}

		

//Word Repetition Checker
// Variable to track whether word repetition highlighting is on or off
var isRepetitionHighlightingOn = false;

// Function to highlight repeated words
function highlightRepetitions() {
    var editor = tinymce.get('tiny');
    var rootNode = editor.getBody();

    findAndHighlightWordRepeats(rootNode);
    isRepetitionHighlightingOn = true;
}

// Function to toggle repetition highlighting
function toggleRepetitionHighlighting() {
    var editor = tinymce.get('tiny');
    var rootNode = editor.getBody();
	var toggleButton = $('.repetition-checker');

    if (isRepetitionHighlightingOn) {
        removeRepetitionHighlighting(rootNode);
        isRepetitionHighlightingOn = false;
		toggleButton.text('Repetition Checker');
    } else {
        highlightRepetitions();
		toggleButton.text('Remove Repetition Highlights');
    }
}

// Function to find and highlight repeated words
function findAndHighlightWordRepeats(rootNode) {
    const excludedWords = [
        'your', 'yours', 'ours', 'they', 'their', 'them', 
        'that', 'will', 'which', 'this', 'those', 'these', 
        'where', 'when', 'how', 'why', 'what', 'who', 
        'whom', 'whose', 'can', 'could', 'should', 'would', 
        'might', 'may', 'must', 'shall', 'do', 'does', 
        'did', 'done', 'am', 'is', 'are', 'was', 'were', 
        'be', 'being', 'been', 'have', 'has', 'had', 'with'
    ];

    function highlightRepeatedWords(words, positions) {
        for (var word in positions) {
            var wordPositions = positions[word];
            var highlighted = []; // To track which positions have been highlighted

            // Iterate through pairs of word positions
            for (var i = 0; i < wordPositions.length - 1; i++) {
                for (var j = i + 1; j < wordPositions.length; j++) {
                    var start = wordPositions[i];
                    var end = wordPositions[j];
                    var charDistance = end.position - start.position;

                    // Check if either position has already been highlighted with a short repetition
                    if (highlighted.includes(start.index) || highlighted.includes(end.index)) {
                        continue;
                    }

                    // Apply the highlight based on distance
                    if (charDistance >= 10 && charDistance <= 130) {
                        words[start.index] = `<span style="background-color: #FFA500;">${words[start.index]}</span>`;
                        words[end.index] = `<span style="background-color: #FFA500;">${words[end.index]}</span>`;
                        highlighted.push(start.index, end.index); // Mark these as highlighted for short repetition
                    } else if (charDistance >= 131 && charDistance <= 300) {
                        // Only highlight with long repetition if not already highlighted
                        if (!highlighted.includes(start.index)) {
                            words[start.index] = `<span style="background-color: #00ffd0;">${words[start.index]}</span>`;
                        }
                        if (!highlighted.includes(end.index)) {
                            words[end.index] = `<span style="background-color: #00ffd0;">${words[end.index]}</span>`;
                        }
                    }
                }
            }
        }
    }

    function traverseAndHighlight(node) {
        var words = [];
        var positions = {};
        var currentPosition = 0;

        function processNode(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                var nodeWords = node.nodeValue.split(/(\p{L}+)/gu);
                for (var i = 0; i < nodeWords.length; i++) {
                    var word = nodeWords[i].toLowerCase();
                    if (word.length >= 4 && /\p{L}/u.test(word) && !excludedWords.includes(word)) {
                        if (!positions[word]) {
                            positions[word] = [];
                        }
                        positions[word].push({ position: currentPosition, index: words.length });
                    }
                    words.push(nodeWords[i]);
                    currentPosition += nodeWords[i].length;
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                for (var i = 0; i < node.childNodes.length; i++) {
                    processNode(node.childNodes[i]);
                }
            }
        }

        function applyHighlights(node, words, position) {
            if (node.nodeType === Node.TEXT_NODE) {
                var nodeWords = node.nodeValue.split(/(\p{L}+)/gu);
                var highlightedText = '';
                for (var i = 0; i < nodeWords.length; i++) {
                    highlightedText += words[position++];
                }
                if (highlightedText !== node.nodeValue) {
                    var wrapper = document.createElement('span');
                    wrapper.innerHTML = highlightedText;
                    node.parentNode.replaceChild(wrapper, node);
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                for (var i = 0; i < node.childNodes.length; i++) {
                    position = applyHighlights(node.childNodes[i], words, position);
                }
            }
            return position;
        }

        processNode(node);
        highlightRepeatedWords(words, positions);
        applyHighlights(node, words, 0);
    }

    traverseAndHighlight(rootNode);
}


// Function to remove repetition highlighting
function removeRepetitionHighlighting(rootNode) {
    var highlightedSpans = rootNode.querySelectorAll('span[style="background-color: #FFA500;"], span[style="background-color: #00ffd0;"]');

    highlightedSpans.forEach(function (span) {
        var parent = span.parentNode;
        while (span.firstChild) {
            parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
    });

    // Reinitialize content to ensure no leftover spans exist
    var editor = tinymce.get('tiny');
    var content = editor.getContent();
    editor.setContent(content);  // This resets TinyMCE's internal state
}

// Adding event listener to the button
var repetitionCheckerBtn = document.querySelector('.repetition-checker');
repetitionCheckerBtn.addEventListener('click', toggleRepetitionHighlighting);

        //Return to Top Button
		// Add event listener for scroll event
		window.addEventListener('scroll', function() {
			// Get the height of the page
			var pageHeight = document.documentElement.scrollHeight;
			
			// Calculate the threshold for showing the button (2/3 of the page height)
			var threshold = (1/6) * pageHeight;
			
			// Get the "Return to Top" button element
			var returnToTopButton = document.querySelector('.return-to-top-button');
			
			// Show or hide the "Return to Top" button based on the scroll position
			if (window.scrollY > threshold) { // Show button if scrolled down to 2/3 of the page
				returnToTopButton.style.display = 'block';
			} else {
				returnToTopButton.style.display = 'none';
			}
		});

		// Function to scroll back to the top of the page
		function returnToTop() {
			window.scrollTo({ top: 0, behavior: 'smooth' });
		}

        
		//Hemingway Tool
		function toggleHemingwayTool() {
            var hemingwayArea = document.querySelector('.hemingway-area');
            var hemingwayToolButton = document.querySelector('.hemingway-tool');

            if (hemingwayArea.style.display === 'none') {
                hemingwayArea.style.display = 'block';
                hemingwayToolButton.textContent = 'Hide Readability Tool';
            } else {
                hemingwayArea.style.display = 'none';
                hemingwayToolButton.textContent = 'Readability Tool';
            }

            // Toggle the visibility of the Keyword area as well
            var keywordArea = document.querySelector('.keywords');
            keywordArea.style.display = hemingwayArea.style.display === 'block' ? 'none' : 'block';
        }

        // Bind the function to the button click event
        var hemingwayToolButton = document.querySelector('.hemingway-tool');
        hemingwayToolButton.addEventListener('click', toggleHemingwayTool);

function calculateLevel(letters, words, sentences) {
    if (words === 0 || sentences === 0) {
        return 0;
    }
    let level = Math.round(
        4.71 * (letters / words) + 0.5 * words / sentences - 21.43
    );
    return level <= 0 ? 0 : level;
}

function getSentenceFromParagraph(p) {
    let sentences = p
        .split(/[\.\?!]\s|\n/g)  // Split on period, exclamation mark, or question mark followed by a space, or newline
        .filter(s => s.trim().length > 0)  // Remove empty sentences
        .map(s => s.trim() + '.');  // Add a period at the end of each sentence
    return sentences;
}

function getLyWords() {
    return {
        actually: 1,
				  additionally: 1,
				  allegedly: 1,
				  ally: 1,
				  alternatively: 1,
				  anomaly: 1,
				  apply: 1,
				  approximately: 1,
				  ashely: 1,
				  ashly: 1,
				  assembly: 1,
				  awfully: 1,
				  baily: 1,
				  belly: 1,
				  bely: 1,
				  billy: 1,
				  bradly: 1,
				  bristly: 1,
				  bubbly: 1,
				  bully: 1,
				  burly: 1,
				  butterfly: 1,
				  carly: 1,
				  charly: 1,
				  chilly: 1,
				  comely: 1,
				  comply: 1,
				  consequently: 1,
				  costly: 1,
				  courtly: 1,
				  crinkly: 1,
				  crumbly: 1,
				  cuddly: 1,
				  curly: 1,
				  currently: 1,
				  daily: 1,
				  dastardly: 1,
				  deadly: 1,
				  deathly: 1,
				  definitely: 1,
				  dilly: 1,
				  disorderly: 1,
				  doily: 1,
				  dolly: 1,
				  dragonfly: 1,
				  early: 1,
				  elderly: 1,
				  elly: 1,
				  emily: 1,
				  especially: 1,
				  exactly: 1,
				  exclusively: 1,
				  family: 1,
				  finally: 1,
				  firefly: 1,
				  folly: 1,
				  friendly: 1,
				  frilly: 1,
				  gadfly: 1,
				  gangly: 1,
				  generally: 1,
				  ghastly: 1,
				  giggly: 1,
				  globally: 1,
				  goodly: 1,
				  gravelly: 1,
				  grisly: 1,
				  gully: 1,
				  haily: 1,
				  hally: 1,
				  harly: 1,
				  hardly: 1,
				  heavenly: 1,
				  hillbilly: 1,
				  hilly: 1,
				  holly: 1,
				  holy: 1,
				  homely: 1,
				  homily: 1,
				  horsefly: 1,
				  hourly: 1,
				  immediately: 1,
				  instinctively: 1,
				  imply: 1,
				  italy: 1,
				  jelly: 1,
				  jiggly: 1,
				  jilly: 1,
				  jolly: 1,
				  july: 1,
				  karly: 1,
				  kelly: 1,
				  kindly: 1,
				  lately: 1,
				  likely: 1,
				  lilly: 1,
				  lily: 1,
				  lively: 1,
				  lolly: 1,
				  lonely: 1,
				  lovely: 1,
				  lowly: 1,
				  luckily: 1,
				  mealy: 1,
				  measly: 1,
				  melancholy: 1,
				  mentally: 1,
				  molly: 1,
				  monopoly: 1,
				  multiply: 1,
				  nightly: 1,
				  oily: 1,
				  orderly: 1,
				  panoply: 1,
				  particularly: 1,
				  partly: 1,
				  paully: 1,
				  pearly: 1,
				  pebbly: 1,
				  polly: 1,
				  potbelly: 1,
				  presumably: 1,
				  previously: 1,
				  pualy: 1,
				  quarterly: 1,
				  rally: 1,
				  rarely: 1,
				  recently: 1,
				  rely: 1,
				  reply: 1,
				  reportedly: 1,
				  roughly: 1,
				  sally: 1,
				  scaly: 1,
				  shapely: 1,
				  shelly: 1,
				  shirly: 1,
				  shortly: 1,
				  sickly: 1,
				  silly: 1,
				  sly: 1,
				  smelly: 1,
				  sparkly: 1,
				  spindly: 1,
				  spritely: 1,
				  squiggly: 1,
				  stately: 1,
				  steely: 1,
				  supply: 1,
				  surly: 1,
				  tally: 1,
				  timely: 1,
				  trolly: 1,
				  ugly: 1,
				  underbelly: 1,
				  unholy: 1,
				  unlikely: 1,
				  usually: 1,
				  waverly: 1,
				  wholly: 1,
				  willy: 1,
				  wily: 1,
				  wobbly: 1,
				  wooly: 1,
				  worldly: 1,
				  wrinkly: 1,
				  yearly: 1
    };
}

function getAdverbs(sentence) {
    let lyWords = getLyWords();
    return sentence
        .split(" ")
        .map(word => {
            if (
                word.replace(/[^a-z0-9. ]/gi, "").match(/ly$/) &&
                lyWords[word.replace(/[^a-z0-9. ]/gi, "").toLowerCase()] === undefined
            ) {
                return `<span class="adverb">${word}</span>`;
            } else {
                return word;
            }
        })
        .join(" ");
}

function checkPrewords(words, originalWords, match) {
    let preWords = ["is", "are", "was", "were", "be", "been", "being"];
    let index = words.indexOf(match);
    if (preWords.indexOf(words[index - 1]) >= 0) {
        originalWords[index - 1] =
            '<span class="passive">' + originalWords[index - 1];
        originalWords[index] = originalWords[index] + "</span>";
        let next = checkPrewords(
            words.slice(index + 1),
            originalWords.slice(index + 1),
            match
        );
        return [...originalWords.slice(0, index + 1), ...next];
    } else {
        return originalWords;
    }
}

function getPassive(sent) {
    let originalWords = sent.split(" ");
    let words = sent
        .replace(/[^a-z0-9. ]/gi, "")
        .toLowerCase()
        .split(" ");
    let ed = words.filter(word => word.match(/ed$/));
    if (ed.length > 0) {
        ed.forEach(match => {
            originalWords = checkPrewords(words, originalWords, match);
        });
    }
    return originalWords.join(" ");
}

function findAndSpan(sentence, phrase, className) {
    var re = new RegExp('\\b' + phrase + '\\b', 'gi');
    return sentence.replace(re, `<span class="${className}">${phrase}</span>`);
}

function getComplexWords() {
    return {
        "a number of": ["many", "some"],
				  abundance: ["enough", "plenty"],
				  "accede to": ["allow", "agree to"],
				  accelerate: ["speed up"],
				  accentuate: ["stress"],
				  accompany: ["go with", "with"],
				  accomplish: ["do"],
				  accorded: ["given"],
				  accrue: ["add", "gain"],
				  acquiesce: ["agree"],
				  acquire: ["get"],
				  additional: ["more", "extra"],
				  "adjacent to": ["next to"],
				  adjustment: ["change"],
				  admissible: ["allowed", "accepted"],
				  advantageous: ["helpful"],
				  "adversely impact": ["hurt"],
				  advise: ["tell"],
				  aforementioned: ["remove"],
				  aggregate: ["total", "add"],
				  aircraft: ["plane"],
				  "all of": ["all"],
				  alleviate: ["ease", "reduce"],
				  allocate: ["divide"],
				  "along the lines of": ["like", "as in"],
				  "already existing": ["existing"],
				  alternatively: ["or"],
				  ameliorate: ["improve", "help"],
				  anticipate: ["expect"],
				  apparent: ["clear", "plain"],
				  appreciable: ["many"],
				  "as a means of": ["to"],
				  "as of yet": ["yet"],
				  "as to": ["on", "about"],
				  "as yet": ["yet"],
				  ascertain: ["find out", "learn"],
				  assistance: ["help"],
				  "at this time": ["now"],
				  attain: ["meet"],
				  "attributable to": ["because"],
				  authorize: ["allow", "let"],
				  "because of the fact that": ["because"],
				  belated: ["late"],
				  "benefit from": ["enjoy"],
				  bestow: ["give", "award"],
				  "by virtue of": ["by", "under"],
				  cease: ["stop"],
				  "close proximity": ["near"],
				  commence: ["begin or start"],
				  "comply with": ["follow"],
				  concerning: ["about", "on"],
				  consequently: ["so"],
				  consolidate: ["join", "merge"],
				  constitutes: ["is", "forms", "makes up"],
				  demonstrate: ["prove", "show"],
				  depart: ["leave", "go"],
				  designate: ["choose", "name"],
				  discontinue: ["drop", "stop"],
				  "due to the fact that": ["because", "since"],
				  "each and every": ["each"],
				  economical: ["cheap"],
				  eliminate: ["cut", "drop", "end"],
				  elucidate: ["explain"],
				  employ: ["use"],
				  endeavor: ["try"],
				  enumerate: ["count"],
				  equitable: ["fair"],
				  equivalent: ["equal"],
				  evaluate: ["test", "check"],
				  evidenced: ["showed"],
				  exclusively: ["only"],
				  expedite: ["hurry"],
				  expend: ["spend"],
				  expiration: ["end"],
				  facilitate: ["ease", "help"],
				  "factual evidence": ["facts", "evidence"],
				  feasible: ["workable"],
				  finalize: ["complete", "finish"],
				  "first and foremost": ["first"],
				  "for the purpose of": ["to"],
				  forfeit: ["lose", "give up"],
				  formulate: ["plan"],
				  "honest truth": ["truth"],
				  however: ["but", "yet"],
				  "if and when": ["if", "when"],
				  impacted: ["affected", "harmed", "changed"],
				  implement: ["install", "put in place", "tool"],
				  "in a timely manner": ["on time"],
				  "in accordance with": ["by", "under"],
				  "in addition": ["also", "besides", "too"],
				  "in all likelihood": ["probably"],
				  "in an effort to": ["to"],
				  "in between": ["between"],
				  "in excess of": ["more than"],
				  "in lieu of": ["instead"],
				  "in light of the fact that": ["because"],
				  "in many cases": ["often"],
				  "in order to": ["to"],
				  "in regard to": ["about", "concerning", "on"],
				  "in some instances ": ["sometimes"],
				  "in terms of": ["omit"],
				  "in the near future": ["soon"],
				  "in the process of": ["omit"],
				  inception: ["start"],
				  "incumbent upon": ["must"],
				  indicate: ["say", "state", "or show"],
				  indication: ["sign"],
				  initiate: ["start"],
				  "is applicable to": ["applies to"],
				  "is authorized to": ["may"],
				  "is responsible for": ["handles"],
				  "it is essential": ["must", "need to"],
				  literally: ["omit"],
				  magnitude: ["size"],
				  maximum: ["greatest", "largest", "most"],
				  methodology: ["method"],
				  minimize: ["cut"],
				  minimum: ["least", "smallest", "small"],
				  modify: ["change"],
				  monitor: ["check", "watch", "track"],
				  multiple: ["many"],
				  necessitate: ["cause", "need"],
				  nevertheless: ["still", "besides", "even so"],
				  "not certain": ["uncertain"],
				  "not many": ["few"],
				  "not often": ["rarely"],
				  "not unless": ["only if"],
				  "not unlike": ["similar", "alike"],
				  notwithstanding: ["in spite of", "still"],
				  "null and void": ["use either null or void"],
				  numerous: ["many"],
				  objective: ["aim", "goal"],
				  obligate: ["bind", "compel"],
				  obtain: ["get"],
				  "on the contrary": ["but", "so"],
				  "on the other hand": ["omit", "but", "so"],
				  "one particular": ["one"],
				  optimum: ["best", "greatest", "most"],
				  overall: ["omit"],
				  "owing to the fact that": ["because", "since"],
				  participate: ["take part"],
				  particulars: ["details"],
				  "pass away": ["die"],
				  "pertaining to": ["about", "of", "on"],
				  "point in time": ["time", "point", "moment", "now"],
				  portion: ["part"],
				  possess: ["have", "own"],
				  preclude: ["prevent"],
				  previously: ["before"],
				  "prior to": ["before"],
				  prioritize: ["rank", "focus on"],
				  procure: ["buy", "get"],
				  proficiency: ["skill"],
				  "provided that": ["if"],
				  purchase: ["buy", "sale"],
				  "put simply": ["omit"],
				  "readily apparent": ["clear"],
				  "refer back": ["refer"],
				  regarding: ["about", "of", "on"],
				  relocate: ["move"],
				  remainder: ["rest"],
				  remuneration: ["payment"],
				  require: ["must", "need"],
				  requirement: ["need", "rule"],
				  reside: ["live"],
				  residence: ["house"],
				  retain: ["keep"],
				  satisfy: ["meet", "please"],
				  shall: ["must", "will"],
				  "should you wish": ["if you want"],
				  "similar to": ["like"],
				  solicit: ["ask for", "request"],
				  "span across": ["span", "cross"],
				  strategize: ["plan"],
				  subsequent: ["later", "next", "after", "then"],
				  substantial: ["large", "much"],
				  "successfully complete": ["complete", "pass"],
				  sufficient: ["enough"],
				  terminate: ["end", "stop"],
				  "the month of": ["omit"],
				  therefore: ["thus", "so"],
				  "this day and age": ["today"],
				  "time period": ["time", "period"],
				  "took advantage of": ["preyed on"],
				  transmit: ["send"],
				  transpire: ["happen"],
				  "until such time as": ["until"],
				  utilization: ["use"],
				  utilize: ["use"],
				  validate: ["confirm"],
				  "various different": ["various", "different"],
				  "whether or not": ["whether"],
				  "with respect to": ["on", "about"],
				  "with the exception of": ["except for"],
				  witnessed: ["saw", "seen"]
    };
}

function getComplex(sentence) {
    let words = getComplexWords();
    let wordList = Object.keys(words);
    wordList.forEach(key => {
        sentence = findAndSpan(sentence, key, "complex");
    });
    return sentence;
}

function getQualifyingWords() {
    return {
        "i believe": 1,
				  "i consider": 1,
				  "i don't believe": 1,
				  "i don't consider": 1,
				  "i don't feel": 1,
				  "i don't suggest": 1,
				  "i don't think": 1,
				  "i feel": 1,
				  "i hope to": 1,
				  "i might": 1,
				  "i suggest": 1,
				  "i think": 1,
				  "i was wondering": 1,
				  "i will try": 1,
				  "i wonder": 1,
				  "in my opinion": 1,
				  "is kind of": 1,
				  "is sort of": 1,
				  just: 1,
				  maybe: 1,
				  perhaps: 1,
				  possibly: 1,
				  "we believe": 1,
				  "we consider": 1,
				  "we don't believe": 1,
				  "we don't consider": 1,
				  "we don't feel": 1,
				  "we don't suggest": 1,
				  "we don't think": 1,
				  "we feel": 1,
				  "we hope to": 1,
				  "we might": 1,
				  "we suggest": 1,
				  "we think": 1,
				  "we were wondering": 1,
				  "we will try": 1,
				  "we wonder": 1
    };
}

function getQualifier(sentence) {
    let qualifiers = getQualifyingWords();
    let wordList = Object.keys(qualifiers);
    wordList.forEach(key => {
        sentence = findAndSpan(sentence, key, "qualifier");
    });
    return sentence;
}

function getDifficultSentences(p) {
    let sentences = getSentenceFromParagraph(p + " ");
    let hardOrNot = sentences.map(sent => {
        let cleanSentence = sent.replace(/[^a-z0-9. ]/gi, "") + ".";
        let words = cleanSentence.split(" ").length;
        let letters = cleanSentence.split(" ").join("").length;
        sent = getAdverbs(sent);
        sent = getComplex(sent);
        sent = getPassive(sent);
        sent = getQualifier(sent);
        let level = calculateLevel(letters, words, 1);
        if (words < 14) {
            return sent;
        } else if (level >= 10 && level < 14) {
            return `<span class="hardSentence">${sent}</span>`;
        } else if (level >= 14) {
            return `<span class="veryHardSentence">${sent}</span>`;
        } else {
            return sent;
        }
    });

    return hardOrNot.join(" ");
}

function HemingwayCalculator() {
    var text = tinyMCE.activeEditor.getContent({format: 'text'}); // Use TinyMCE's API to get the content

    // Calculate the number of letters, words, and sentences
    var letters = text.replace(/[^a-z]/gi, '').length;
    var words = text.match(/\S+/g) ? text.match(/\S+/g).length : 0; // matches any non-whitespace character
    var sentences = getSentenceFromParagraph(text);
    var sentenceCount = sentences.length;

    // Calculate the number of adverbs
    var adverbs = getAdverbs(text).match(/<span class="adverb">/g);
    var adverbCount = adverbs ? adverbs.length : 0;

    // Calculate the number of instances of passive voice
    var passive = getPassive(text).match(/<span class="passive">/g);
    var passiveCount = passive ? passive.length : 0;

    // Calculate the number of complex phrases
    var complex = getComplex(text).match(/<span class="complex">/g);
    var complexCount = complex ? complex.length : 0;

    // Calculate the number of hard and very hard sentences
    var difficultSentences = getDifficultSentences(text);
    var hardSentences = difficultSentences.match(/<span class="hardSentence">/g);
    var hardSentenceCount = hardSentences ? hardSentences.length : 0;
    var veryHardSentences = difficultSentences.match(/<span class="veryHardSentence">/g);
    var veryHardSentenceCount = veryHardSentences ? veryHardSentences.length : 0;

    // Calculate the number of qualifiers
    var qualifiers = getQualifier(text).match(/<span class="qualifier">/g);
    var qualifierCount = qualifiers ? qualifiers.length : 0;

    // Calculate the readability level
    var level = calculateLevel(letters, words, sentenceCount); // Pass sentenceCount, not sentences
	
	// Determine the readability grade description
    var gradeDescription;
    if (level <= 9) {
        gradeDescription = "(Good)";
    } else if (level === 10) {
        gradeDescription = "(OK)";
    } else if (level === 11) {
        gradeDescription = "(Hard)";
    } else if (level >= 12) {
        gradeDescription = "(Very Hard)";
    }

    document.getElementById('hemingway-grade').textContent = level + " " + gradeDescription;

    // Display the number of adverbs
    document.getElementById('adverb').innerHTML = `You have used ${adverbCount} adverb${adverbCount > 1 ? "s" : ""}. Try to use ${Math.round(sentenceCount * 0.21)} or less.`;

    // Display the number of instances of passive voice
    document.getElementById('passive').innerHTML = `You have used passive voice ${passiveCount} time${passiveCount > 1 ? "s" : ""}. Aim for ${Math.round(sentenceCount / 5)} or less.`;

    // Display the number of complex phrases
    document.getElementById('complex').innerHTML = `${complexCount} phrase${complexCount > 1 ? "s" : ""} could be simplified.`;

    // Display the number of hard and very hard sentences
    document.getElementById('hardSentence').innerHTML = `${hardSentenceCount} of ${sentenceCount} sentence${sentenceCount > 1 ? "s are" : " is"} hard to read`;
    document.getElementById('veryHardSentence').innerHTML = `${veryHardSentenceCount} of ${sentenceCount} sentence${sentenceCount > 1 ? "s are" : " is"} very hard to read`;

    // Display the number of qualifiers
    // Add a new element to your HTML to display this information
    document.getElementById('qualifier').innerHTML = `${qualifierCount} qualifying phrase${qualifierCount > 1 ? "s" : ""} could be simplified.`;
	
	    // Update the content of the Tiny editor with the highlighted text
    tinyMCE.activeEditor.setContent(difficultSentences);

}


document.querySelector('.HemBtn').addEventListener('click', HemingwayCalculator);

function RemoveHemFormat() {
    var text = tinyMCE.activeEditor.getContent({format: 'html'}); // Use TinyMCE's API to get the content

    // Remove the span elements
    var cleanedText = text.replace(/<span class="adverb">|<span class="passive">|<span class="complex">|<span class="hardSentence">|<span class="veryHardSentence">|<\/span>/g, '');

    // Set the content of the Tiny editor to the cleaned text
    tinyMCE.activeEditor.setContent(cleanedText);
}
// End of Readability App


// Keyword Stuffing Checker
function toggleKeywordStuffingChecker() {
    var keywordStuffingArea = $('.keyword-stuffing-area');
	var keywordsArea = $('.keywords');
    var toggleButton = $('.keyword-stuffing-btn');

    // Toggle visibility
	if (keywordStuffingArea.is(':visible')) {
		keywordStuffingArea.hide();
		keywordsArea.show();
		toggleButton.text('Word Density Checker');
	} else {
		keywordStuffingArea.show();
		keywordsArea.hide();
        toggleButton.text('Hide Word Density Checker');
	}	
}

function analyzeText() {
    // Get the content of the TinyMCE editor
    var content = tinymce.get('tiny').getContent({ format: 'text' });

    // Define a list of common words to be excluded
    var excludedWords = ['a', 'an', 'the', 'and', 'but', 'or', 'nor', 'for', 'so', 'yet', 'to', 'only', 'there', 'make', 'them', 'they', 'have', 'also', 'in', 'on', 'at', 'by', 'with', 'of', 'from', 'up', 'down', 'about', 'into', 'over', 'under', 'between', 'through', 'above', 'below', 'within', 'without', 'before', 'after', 'during', 'since', 'while', 'throughout', 'among', 'beside', 'along', 'toward', 'against', 'across', 'amongst', 'like', 'near', 'through', 'behind', 'beneath', 'inside', 'outside', 'onto', 'upon', 'off', 'around', 'underneath', 'whether', 'who', 'whom', 'whose', 'which', 'that', 'what', 'where', 'when', 'why', 'how', 'all', 'any', 'each', 'every', 'few', 'some', 'several', 'many', 'much', 'more', 'most', 'other', 'another', 'such', 'this', 'these', 'those', 'own', 'my', 'your', 'his', 'her', 'its', 'our', 'their'];

    // Split the content into an array of words
    var words = content.split(/\s+/);

    // Create an object to store word frequencies
    var wordFreq = {};

    // Iterate through the words and count their occurrences
    words.forEach(function(word) {
        // Normalize the word by converting it to lowercase and normalizing Unicode characters
        word = word.toLowerCase();
        word = word.normalize('NFKD'); // Normalize Unicode characters
        // Remove non-alphanumeric characters from the word
        word = word.replace(/[^a-zA-Z0-9]/g, '');
        // Skip words with less than 4 characters or words in the excluded list
        if (word.length < 4 || excludedWords.includes(word)) return;
        // Increment the count for the word
        if (wordFreq[word]) {
            wordFreq[word]++;
        } else {
            wordFreq[word] = 1;
        }
    });

    // Sort the words by frequency
    var sortedWords = Object.keys(wordFreq).sort(function(a, b) {
        return wordFreq[b] - wordFreq[a];
    });

    // Display the top 20 words and their densities
		var result = '<h2>Top 20 words by density</h2>';
		result += '<table border="1"><tr><th>Word</th><th>N° of uses</th><th>Density</th></tr>';
		for (var i = 0; i < Math.min(20, sortedWords.length); i++) {
			var word = sortedWords[i];
			var frequency = wordFreq[word];
			var density = (frequency / words.length * 100).toFixed(2); // Calculate density as a percentage
			result += '<tr><td>' + word + '</td><td>' + frequency + '</td><td>' + density + '%</td></tr>';
		}
		result += '</table>';


    // Display the result in a div
    document.getElementById('wordAnalysisResult').innerHTML = result;
}

//Density Calculator

function toggleDensityCalculator() {
    var densityCalculator = $('.density-calculator-container');
    var keywordsArea = $('.keywords');
    var toggleButton = $('#toggleDensityButton'); // Assuming the button has an ID of 'toggleDensityButton'
    
    if (densityCalculator.is(':visible')) {
        densityCalculator.hide();
        keywordsArea.show();
        toggleButton.text('Density Calculator');
    } else {
        densityCalculator.show();
        keywordsArea.hide();
        toggleButton.text('Hide Density Calculator');
    }
}

function addDensityField() {
    $('#densityCalculatorFields').append(
        '<div class="density-calculation-row">' +
        '<input type="text" class="word-count" placeholder="Enter word count (e.g., 1300 or 1300-1500)">' +
        '<input type="text" class="kw-density" placeholder="Enter desired KW density (e.g., 3%)">' +
        '<input type="text" class="density-result" readonly placeholder="Result">' +
        '<button class="remove-field" onclick="removeField(this)">Remove</button>' +
        '</div>'
    );
}

function removeField(button) {
    $(button).parent().remove();
}

function calculateDensity() {
    $('.density-calculation-row').each(function () {
        var wordCount = $(this).find('.word-count').val().trim();
        var kwDensity = $(this).find('.kw-density').val().trim();
        var resultField = $(this).find('.density-result');

        if (wordCount && kwDensity) {
            var countRange = wordCount.split('-').map(Number);
            var density = parseFloat(kwDensity.replace('%', ''));

            if (countRange.length === 1) {
                var result = Math.round(countRange[0] * (density / 100));
                resultField.val(result);
            } else if (countRange.length === 2) {
                var resultMin = Math.round(countRange[0] * (density / 100));
                var resultMax = Math.round(countRange[1] * (density / 100));
                resultField.val(resultMin + ' - ' + resultMax);
            } else {
                resultField.val('Invalid input');
            }
        } else {
            resultField.val('Invalid input');
        }
    });
}

//KW extractor
function toggleKWExtraction() {
	var toggleButton = $('#kw-extraction-btn');
    const kwExtractionArea = document.querySelector('.kw-extraction-area');
	
    if (kwExtractionArea.style.display === 'none' || kwExtractionArea.style.display === '') {
        kwExtractionArea.style.display = 'block';
		toggleButton.text('Hide KW Extraction');
    } else {
        kwExtractionArea.style.display = 'none';
		toggleButton.text('KW Extraction');
    }
}

function transformKWList() {
    const input = document.getElementById('kw-input').value.trim();
    if (!input) {
        alert('Please enter a list of KWs.');
        return;
    }

    const lines = input.split('\n');
    const keywords = [];
    const uses = [];

    // Patterns to match colons and parentheses for trimming
    const kwTrimPattern = /[:\(]/;  // Matches the first occurrence of ":" or "("
    const useTrimPattern = /[:\(]/;  // Matches the first occurrence of ":" or "("

    lines.forEach(line => {
        // Extract Keyword: Trim everything after (and including) the first colon or parenthesis
        const kwMatch = line.split(kwTrimPattern)[0].trim();
        keywords.push(kwMatch);

        // Extract Use: Trim everything before (and including) the first colon or parenthesis
        let useMatch = line.split(useTrimPattern)[1];
        if (useMatch) {
            // Remove everything except numbers, hyphens, and "%" symbols after the first number
            useMatch = useMatch.replace(/[^\d\-%]/g, '').trim();
            uses.push(useMatch);
        } else {
            uses.push('-');  // If no number found, indicate with a dash
        }
    });

    // Display the results
    displayResults(keywords, uses);
}

function displayResults(keywords, uses) {
    const kwList = document.getElementById('kw-list');
    const usesList = document.getElementById('uses-list');

    // Clear previous results
    kwList.innerHTML = '';
    usesList.innerHTML = '';

    // Append new results without bullet points
    keywords.forEach(kw => {
        const div = document.createElement('div');
        div.textContent = kw;
        kwList.appendChild(div);
    });

    uses.forEach(use => {
        const div = document.createElement('div');
        div.textContent = use;
        usesList.appendChild(div);
    });
}

// Function to toggle the Meta Title and Description area
function toggleMetaArea() {
    var metaToolArea = $('.meta-tool-area');
	var keywordsArea = $('.keywords');
    var toggleButton = $('#toggle-meta-btn');

    if (metaToolArea.is(':visible')) {
        metaToolArea.hide();
        keywordsArea.show();
        toggleButton.text('Meta T&D');
    } else {
        metaToolArea.show();
        keywordsArea.hide();
		toggleButton.text('Hide Meta T&D');
    }
}

// Function to check Meta Title length and provide feedback
function checkMetaTitle() {
    const metaTitle = document.getElementById('meta-title').value;
    const titleMin = parseInt(document.getElementById('title-min').value);
    const titleMax = parseInt(document.getElementById('title-max').value);
    const charCount = metaTitle.length;
    const feedback = document.getElementById('meta-title-feedback');

    feedback.innerHTML = `Character Count: ${charCount}`;

    if (charCount < titleMin) {
        feedback.innerHTML += ' - Too short';
        feedback.style.color = 'red';
    } else if (charCount > titleMax) {
        feedback.innerHTML += ' - Too long';
        feedback.style.color = 'red';
    } else {
        feedback.innerHTML += ' - Within range';
        feedback.style.color = 'blue';  // Changed to blue for better accessibility
    }
}

// Function to check Meta Description length and provide feedback
function checkMetaDescription() {
    const metaDescription = document.getElementById('meta-description').value;
    const descriptionMin = parseInt(document.getElementById('description-min').value);
    const descriptionMax = parseInt(document.getElementById('description-max').value);
    const charCount = metaDescription.length;
    const feedback = document.getElementById('meta-description-feedback');

    feedback.innerHTML = `Character Count: ${charCount}`;

    if (charCount < descriptionMin) {
        feedback.innerHTML += ' - Too short';
        feedback.style.color = 'red';
    } else if (charCount > descriptionMax) {
        feedback.innerHTML += ' - Too long';
        feedback.style.color = 'red';
    } else {
        feedback.innerHTML += ' - Within range';
        feedback.style.color = 'blue';  // Changed to blue for better accessibility
    }
}

// Function to add Meta Title and Description at the beginning of the text while preserving formatting
function addMetasToText() {
    const metaTitle = document.getElementById('meta-title').value.trim();
    const metaDescription = document.getElementById('meta-description').value.trim();

    // Ensure both Meta Title and Description are provided
    if (!metaTitle || !metaDescription) {
        alert('Please enter both a Meta Title and Meta Description.');
        return;
    }

    // Format Meta Title and Description with HTML for new lines
    const metaFormatted = `<p>MT: ${metaTitle}</p><p>MD: ${metaDescription}</p>`;

    // Insert Meta Title and Description at the beginning of the text editor content
    const editor = tinymce.get('tiny');  // Replace 'tiny' with the ID of your TinyMCE editor instance
    const currentContent = editor.getContent(); // Get current content in HTML format

    // Set new content with metas at the top while preserving the existing content and formatting
    editor.setContent(metaFormatted + currentContent);
}

// Function to copy the content of a given element to the clipboard
function copyToClipboard(elementId) {
    const content = document.getElementById(elementId).value.trim();
    
    if (content) {
        // Copy content to clipboard
        navigator.clipboard.writeText(content).then(() => {
            
        }).catch(err => {
            console.error('Failed to copy: ', err);
        });
    } else {
        alert('No content to copy.');
    }
}

// Function to copy the entire content of the TinyMCE editor to the clipboard with formatting preserved
function copyEditorContent() {
    const editor = tinymce.get('tiny'); // Replace 'tiny' with the ID of your TinyMCE editor instance
    const content = editor.getContent(); // Get editor content in HTML format

    if (content) {
        // Create a temporary element to hold the HTML content
        const tempElement = document.createElement('div');
        tempElement.innerHTML = content;

        // Append the element to the body
        document.body.appendChild(tempElement);

        // Create a range and select the content
        const range = document.createRange();
        range.selectNodeContents(tempElement);

        // Remove any previous selection and add the new range to the selection
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        // Copy the selected content to the clipboard
        document.execCommand('copy');

        // Remove the temporary element
        document.body.removeChild(tempElement);

        // Show a popup message indicating success
        showPopupMessage('Editor content copied to clipboard!');
    } else {
        showPopupMessage('There is no content to copy.');
    }
}


// Function to show a popup message in the middle of the screen
function showPopupMessage(message) {
    const popup = document.getElementById('copy-popup');
    popup.textContent = message;
    popup.style.display = 'block'; // Make sure the popup is displayed
    popup.style.opacity = '1'; // Start fully visible

    // Fade out after 1 second
    setTimeout(() => {
        popup.style.opacity = '0'; // Gradually fade out
    }, 1000);

    // Hide the popup after it has faded out
    setTimeout(() => {
        popup.style.display = 'none';
    }, 1500); // Delay slightly longer than the fade effect
}

// Function to copy the content of a given element to the clipboard
function copyListContent(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        const content = element.innerText.trim(); // Get text content from the element

        if (content) {
            // Copy content to clipboard
            navigator.clipboard.writeText(content).then(() => {
                showPopupMessage('Content copied to clipboard!'); // Reuse existing popup function for feedback
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        } else {
            showPopupMessage('There is no content to copy.');
        }
    } else {
        console.error(`Element with ID ${elementId} not found.`);
    }
}

// Function to show a popup message in the middle of the screen
function showPopupMessage(message) {
    const popup = document.getElementById('copy-popup');
    popup.textContent = message;
    popup.style.display = 'block'; // Make sure the popup is displayed
    popup.style.opacity = '1'; // Start fully visible

    // Fade out after 1 second
    setTimeout(() => {
        popup.style.opacity = '0'; // Gradually fade out
    }, 1000);

    // Hide the popup after it has faded out
    setTimeout(() => {
        popup.style.display = 'none';
    }, 1500); // Delay slightly longer than the fade effect
}


    </script>
</body>

</html>